---
title: '[翻訳] ウブントで dmg ファイルを iso ファイルで 変更すること'
author: 녹풍(綠風, Windgreen)
layout: post
permalink: /archives/576
aktt_notify_twitter:
  - no
categories:
  - etc
tags:
  - Ubuntu Family
---
検索して 見つけた. ところが 私が レドヘッ リナックスで 試みた 焚く 作動するの なかった. ウブント リナックスで 試みれば 違うか 真書 翻訳して 移す.

原文はUbuntu Quicktip Converting Mac .dmg images into .iso images だ. [2012-07-16 原本 サイトが 消えた;;] 2007年 1月 23仕事に 作成された 文だ.

&#8212;&#8212;&#8212;&#8212;&#8212;-

最近に 有用な スクリプトを 見つけた. 脈 OSX私 アップル アイポッド(イメージで なった ファームウエア)[義 CD イメージ フォーマットである dmgを] 標準 .iso ファイルで 変換して 与える スクリプトだ.

これを 使おうとすれば perlこれ 設置されて あると する. そして perl義 zlib モジュールを 追加で 設置して 与えると する. こんなに 設置する:

<pre class="brush:shell">sudo apt-get install libcompress-zlib-perl
cd /usr/bin
sudo wget http://www.blinkenlights.ch/gnupod/dmg2iso.pl</pre>

ウブントで 使おうとすれば dmg2iso.pl スクリプトで 変更して 竝び 蟹 一つ ある.

<pre class="brush:shell">sudo gedit dmg2iso.pl</pre>

マン 上 竝びに ‘`#!/usr/local/bin/perl`’ して 使って ある ことだ. これは perlを どこで 捜す 数 あるのか 言って 与える のだ. 内 場合に, perl銀 ‘`/usr/bin/perl`’に 設置されて ある. 必要ならば そうに 直して 走者. (訳者 株: ウブント 使用者たちは 直せば なる. ‘`#!/usr/bin/perl`’と 直せば なる.)

今 行う 数 あるように 作って 走者.

<pre class="brush:shell">sudo chmod 777 dmg2iso.pl</pre>

その次 ホーム ディレクトリで 移動する.

<pre>cd</pre>

`bloodspell.dmg` という dmg ファイルが ホーム ディレクトリに あると 梔子. iso ファイルで 変えて たければ 下と 一緒に タイピングする:

<pre class="brush:shell">dmg2iso.pl bloodspell.dmg bloodspell.iso</pre>

それでは スクリプトが 分かって 割 ことだ.

&#8212;&#8212;&#8212;&#8211; 訳者の 追加 : dmg2iso.pl スクリプトの 内容を 移す &#8212;&#8212;&#8212;&#8212;-

<pre class="brush:perl">#!/usr/bin/perl
#
# Downloaded from http://blinkenlights.ch/gnupod/dmg2iso.pl
#
# dmg2iso.pl was written by vu1tur, license ?!?
#
# Note: This doesn&#039;t look like the Version 0.2a provided at
#       http://vu1tur.eu.org/tools/ . But this version works with Apples iPod-Firmware dmg images..
# ...
#
#
use MIME::Base64;
use strict ;
local ($^W) = 1; #use warnings ;
use Compress::Zlib ;
my $x = inflateInit()
   or die "ERROR: Cannot create inflation stream. Is Compress::zlib installed?n" ;
my $zfblock="x00"; for (0..8) { $zfblock.=$zfblock; }
my $indxbeg=0;
my $indxend=0;
my @plist;
print "dmg2iso v0.2a by vu1tur (vu1tur@gmx.de)nn";
if (@ARGV."" != 2) { die "Syntax: dmg2iso.pl filename.dmg filename.ison"; }
my $zeroblock = "x00";
for (0..8) { $zeroblock.=$zeroblock; }
my $tmp;
my ($output,$status);
my $buffer;
open(FINPUT,$ARGV[0]) or die "ERROR: Can&#039;t open input filen";

binmode FINPUT;
sysseek(FINPUT,-0x200000,2);
print "reading property list...";
my $fpos = sysseek(FINPUT,0,1);
while(my $ar = sysread(FINPUT,$buffer,0x10000))
{
	my $fpos = sysseek(FINPUT,0,1)-$ar;
	if ($buffer =‾ /(.*)/s)
	{
		$indxbeg = $fpos+length($1);
	}
	if ($buffer =‾ /(.*)&lt;/plist&gt;/s)
	{
		$indxend = $fpos+length($1)+8;
	}
}
open(FOUTPUT,"&gt;".$ARGV[1]) or die "ERROR: Can&#039;t open output filen";
binmode FOUTPUT;
my $indxcur = $indxbeg + 0x28;
sysseek(FINPUT,$indxbeg,0);
sysread(FINPUT,$tmp,$indxend-$indxbeg);

if ($tmp =‾ s/.*blkx&lt;/key&gt;.*?s*(.*?)&lt;/array&gt;.*/$1/s)
{
	while ($tmp =‾ s/.*?(.*?)&lt;/data&gt;//s)
	{
		my $t = $1;
		$t =‾ s/t//g;
		$t =‾ s/^n//g;
		push @plist,decode_base64($t);
	}
} else {
die "PropertyList is corruptedn";
}
print "found ".@plist." partitionsn";
print "decompressing:n";

my $t=0;
my $zoffs = 0;
my $tempzoffs = 0;
foreach (@plist)
{
	print "partition ".$t++."n";
	s/^.{204}//s;
	while (s/^(.{8})(.{8})(.{8})(.{8})(.{8})//s)
	{
		$x = inflateInit();
		my $block_type = unpack("H*",$1);
		my $out_offs = 0x200*hex(unpack("H*",$2));
		my $out_size = 0x200*hex(unpack("H*",$3));
		my $in_offs = hex(unpack("H*",$4));
		my $in_size = hex(unpack("H*",$5));
		# $1 - block type, $2 - output offs $3 - output size $4 input offset $5 - input size
		sysseek(FINPUT,$in_offs+$zoffs,0);
		sysread(FINPUT,$tmp,$in_size);

		if ($block_type =‾ /^80000005/)
		{
			($output,$status) = $x-&gt;inflate($tmp);
			if ($status == Z_OK or $status == Z_STREAM_END)
			{
				syswrite(FOUTPUT,$output,$out_size);
			} else { die "nConversion failed. File may be corrupted.n"; }
		}
		if  ($block_type =‾ /^00000001/)
		{
			sysseek(FINPUT,$in_offs+$zoffs,0);
			sysread(FINPUT,$tmp,$in_size);
			syswrite(FOUTPUT,$tmp,$out_size);
		}
		if ($block_type =‾ /^00000002/)
		{
			for(1..$out_size/0x200)
			{
				syswrite(FOUTPUT,$zeroblock,0x200);
			}
		}
		if ($block_type =‾ /^FFFFFFFF/i)
		{
			$zoffs += $tempzoffs;
		}
		$tempzoffs = $in_offs+$in_size;
	}
}

print "nconversion successfuln";</pre>