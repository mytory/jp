---
title: '[PHP] RSS 掻いて来る ライブラリ &#8211; lastRSS'
author: 녹풍(綠風, Windgreen)
layout: post
permalink: /archives/169
aktt_notify_twitter:
  - no
mytory_md_path:
  - 
categories:
  - Web server
tags:
  - PHP
---
[2012-07-16 お知らせ : 今 RSS ライブラリで 大勢は <a href="http://www.simplepie.org/" target="_top">SimplePie</a>と する. 私も これから <a href="http://www.simplepie.org/" target="_top">SimplePie</a>を 使う つもりだ.]

提携会社とか 違う 情報 ような のを 自分の ホームページに 見えて 週期 ため RSSを 使う 数 ある. 例えば, 言論社 RSSを 土台で, 自分の ウェブサイトに 該当 言論の 最新 記事を 露出する 数 ある. 自動で.

これ ライブラリは &#8216;PHP RSS リーダー&#8217;という 文で 見つけたし, 使い方 簡単で 良い.lastRSSという ライブラリに ハングル 説明を 団 蟹 下の ソースだ. ハングル 説明は 私 文の 筆者が 団 のだ.

lastRSS 原本 サイトで 直接 原本 ファイルと 例題 などを ボール 数 ある. [2012-07-16 今 原本 サイトが 一時的に 味が 間 ようだ.]

## ソース

原本 サイトが 飛んで ソースも いつ 飛ぶか 分からないから, コピした. GPL ライセンスだから 大丈夫だ.

<pre class="brush: php; gutter: true; first-line: 1; highlight: []; html-script: false">/* 
 ====================================================================== 
 lastRSS 0.9.1 

 Simple yet powerfull PHP class to parse RSS files. 

 by Vojtech Semecky, webmaster @ oslab . net 

 Latest version, features, manual and examples: 

http://lastrss.oslab.net/

 ---------------------------------------------------------------------- 
 LICENSE 

 This program is free software; you can redistribute it and/or 
 modify it under the terms of the GNU General Public License (GPL) 
 as published by the Free Software Foundation; either version 2 
 of the License, or (at your option) any later version. 

 This program is distributed in the hope that it will be useful, 
 but WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 GNU General Public License for more details. 

 To read the license please visit http://www.gnu.org/copyleft/gpl.html 
 ====================================================================== 
*/ 

/** 
* lastRSS 
* Simple yet powerfull PHP class to parse RSS files. 
*/ 
class lastRSS { 
    // ------------------------------------------------------------------- 
    // Public properties 
    // ------------------------------------------------------------------- 
    var $default_cp = 'UTF-8'; 
    var $CDATA = 'nochange'; 
    var $cp = ''; 
    var $items_limit = 0; 
    var $stripHTML = False; 
    var $date_format = ''; 

    // ------------------------------------------------------------------- 
    // Private variables 
    // ------------------------------------------------------------------- 
    var $channeltags = array ('title', 'link', 'description', 'language', 'copyright', 'managingEditor', 'webMaster', 'lastBuildDate', 'rating', 'docs'); 
    var $itemtags = array('title', 'link', 'description', 'author', 'category', 'comments', 'enclosure', 'guid', 'pubDate', 'source'); 
    var $imagetags = array('title', 'url', 'link', 'width', 'height'); 
    var $textinputtags = array('title', 'description', 'name', 'link'); 

    // ------------------------------------------------------------------- 
    // Parse RSS file and returns associative array. 
    // ------------------------------------------------------------------- 
    function Get ($rss_url) { 
        // If CACHE ENABLED 
        if ($this-&gt;cache_dir != '') { 
            $cache_file = $this-&gt;cache_dir . '/rsscache_' . md5($rss_url); 
            $timedif = @(time() - filemtime($cache_file)); 
            if ($timedif &lt; $this-&gt;cache_time) { 
                // cached file is fresh enough, return cached array 
                $result = unserialize(join('', file($cache_file))); 
                // set 'cached' to 1 only if cached file is correct 
                if ($result) $result['cached'] = 1; 
            } else { 
                // cached file is too old, create new 
                $result = $this-&gt;Parse($rss_url); 
                $serialized = serialize($result); 
                if ($f = @fopen($cache_file, 'w')) { 
                    fwrite ($f, $serialized, strlen($serialized)); 
                    fclose($f); 
                } 
                if ($result) $result['cached'] = 0; 
            } 
        } 
        // If CACHE DISABLED &gt;&gt; load and parse the file directly 
        else { 
            $result = $this-&gt;Parse($rss_url); 
            if ($result) $result['cached'] = 0; 
        } 
        // return result 
        return $result; 
    } 

    // ------------------------------------------------------------------- 
    // Modification of preg_match(); return trimed field with index 1 
    // from 'classic' preg_match() array output 
    // ------------------------------------------------------------------- 
    function my_preg_match ($pattern, $subject) { 
        // start regullar expression 
        preg_match($pattern, $subject, $out); 

        // if there is some result... process it and return it 
        if(isset($out[1])) { 
            // Process CDATA (if present) 
            if ($this-&gt;CDATA == 'content') { // Get CDATA content (without CDATA tag) 
                $out[1] = strtr($out[1], array('&lt;![CDATA['=&gt;'', ']]&gt;'=&gt;'')); 
            } elseif ($this-&gt;CDATA == 'strip') { // Strip CDATA 
                $out[1] = strtr($out[1], array('&lt;![CDATA['=&gt;'', ']]&gt;'=&gt;'')); 
            } 

            // If code page is set convert character encoding to required 
            if ($this-&gt;cp != '') 
                //$out[1] = $this-&gt;MyConvertEncoding($this-&gt;rsscp, $this-&gt;cp, $out[1]); 
                $out[1] = iconv($this-&gt;rsscp, $this-&gt;cp.'//TRANSLIT', $out[1]); 
            // Return result 
            return trim($out[1]); 
        } else { 
        // if there is NO result, return empty string 
            return ''; 
        } 
    } 

    // ------------------------------------------------------------------- 
    // Replace HTML entities &something; by real characters 
    // ------------------------------------------------------------------- 
    function unhtmlentities ($string) { 
        // Get HTML entities table 
        $trans_tbl = get_html_translation_table (HTML_ENTITIES, ENT_QUOTES); 
        // Flip keys&lt;==&gt;values 
        $trans_tbl = array_flip ($trans_tbl); 
        // Add support for &apos; entity (missing in HTML_ENTITIES) 
        $trans_tbl += array('&apos;' =&gt; "'"); 
        // Replace entities by values 
        return strtr ($string, $trans_tbl); 
    } 

    // ------------------------------------------------------------------- 
    // Parse() is private method used by Get() to load and parse RSS file. 
    // Don't use Parse() in your scripts - use Get($rss_file) instead. 
    // ------------------------------------------------------------------- 
    function Parse ($rss_url) { 
        // Open and load RSS file 
        if ($f = @fopen($rss_url, 'r')) { 
            $rss_content = ''; 
            while (!feof($f)) { 
                $rss_content .= fgets($f, 4096); 
            } 
            fclose($f); 

            // Parse document encoding 
            $result['encoding'] = $this-&gt;my_preg_match("'encoding=['"](.*?)['"]'si", $rss_content); 
            // if document codepage is specified, use i</pre>