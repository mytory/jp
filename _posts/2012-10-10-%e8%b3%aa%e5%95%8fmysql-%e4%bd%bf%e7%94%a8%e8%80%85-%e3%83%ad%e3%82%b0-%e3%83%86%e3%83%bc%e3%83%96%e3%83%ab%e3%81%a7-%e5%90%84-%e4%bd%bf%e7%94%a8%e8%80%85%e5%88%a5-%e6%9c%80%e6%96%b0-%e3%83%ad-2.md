---
title: '[質問:MySQL] 使用者 ログ テーブルで, 各 使用者別 最新 ログだけ 1竝びずつ, 団 たいてい 番(回)の クイーリーで 持って来ようとすれば?'
author: 녹풍(綠風, Windgreen)
layout: post
permalink: /archives/1610
categories:
  - Web server
tags:
  - MySQL
---
下と ような DB テーブルが ある. id\_person科 id\_classを 連結する relation テーブルだ. 半分が 変わる のを 記録して 累積する.

見れば 卵 数 あるが, 1番(回) id_person銀 2半分であって 4半分であって 1半分が いい.

2番(回) id_person銀 3半分であって 1半分が いい.

<table border="0" cellpadding="0" cellspacing="0" width="360">
  <tr>
    <td height="22">
      id
    </td>
    
    <td>
      id_person
    </td>
    
    <td>
      id_class
    </td>
    
    <td>
      date_written
    </td>
  </tr>
  
  <tr>
    <td>
      53
    </td>
    
    <td>
      <strong><span style="color: #008000;">1</span></strong>
    </td>
    
    <td>
      <strong><span style="color: #008000;">1</span></strong>
    </td>
    
    <td>
      2012-04-05 16:40
    </td>
  </tr>
  
  <tr>
    <td>
      50
    </td>
    
    <td>
      <strong><span style="color: #008000;">1</span></strong>
    </td>
    
    <td>
      <strong><span style="color: #008000;">4</span></strong>
    </td>
    
    <td>
      2012-04-05 16:02
    </td>
  </tr>
  
  <tr>
    <td>
      1
    </td>
    
    <td>
      <strong><span style="color: #008000;">1</span></strong>
    </td>
    
    <td>
      <strong><span style="color: #008000;">2</span></strong>
    </td>
    
    <td>
      2012-03-30 17:56
    </td>
  </tr>
  
  <tr>
    <td>
      2
    </td>
    
    <td>
      <span style="color: #ff0000;"><strong>2</strong></span>
    </td>
    
    <td>
      <span style="color: #ff0000;"><strong>3</strong></span>
    </td>
    
    <td>
      2012-03-30 17:56
    </td>
  </tr>
  
  <tr>
    <td>
      51
    </td>
    
    <td>
      <span style="color: #ff0000;"><strong>2</strong></span>
    </td>
    
    <td>
      <span style="color: #ff0000;"><strong>1</strong></span>
    </td>
    
    <td>
      2012-04-05 16:36
    </td>
  </tr>
  
  <tr>
    <td>
      3
    </td>
    
    <td>
      3
    </td>
    
    <td>
      4
    </td>
    
    <td>
      2012-03-30 17:56
    </td>
  </tr>
  
  <tr>
    <td>
      52
    </td>
    
    <td>
      3
    </td>
    
    <td>
      1
    </td>
    
    <td>
      2012-04-04 16:37
    </td>
  </tr>
  
  <tr>
    <td>
      4
    </td>
    
    <td>
      4
    </td>
    
    <td>
      5
    </td>
    
    <td>
      2012-03-30 17:56
    </td>
  </tr>
  
  <tr>
    <td>
      5
    </td>
    
    <td>
      5
    </td>
    
    <td>
      6
    </td>
    
    <td>
      2012-03-30 17:56
    </td>
  </tr>
  
  <tr>
    <td>
      6
    </td>
    
    <td>
      6
    </td>
    
    <td>
      7
    </td>
    
    <td>
      2012-03-30 17:56
    </td>
  </tr>
  
  <tr>
    <td>
      7
    </td>
    
    <td>
      7
    </td>
    
    <td>
      1
    </td>
    
    <td>
      2012-03-30 17:56
    </td>
  </tr>
  
  <tr>
    <td>
      8
    </td>
    
    <td>
      8
    </td>
    
    <td>
      2
    </td>
    
    <td>
      2012-03-30 17:56
    </td>
  </tr>
  
  <tr>
    <td>
      9
    </td>
    
    <td>
      9
    </td>
    
    <td>
      3
    </td>
    
    <td>
      2012-03-30 17:56
    </td>
  </tr>
</table>

定木, ところが 今 抜こうとする データは 各 id_person これ **今** 何 半分か する ことだ.

## サーブクイーリーで すれば なるが…

これ テーブルのみを 土台で それを 抜く 数 あるか? あった. 下のように クイーリーを 使う ことだ.

<pre class="brush: sql; gutter: true; first-line: 1">SELECT p.*
FROM `person_class_relation_table` AS p
WHERE date_written=(SELECT MAX(date_written) FROM person_class_relation_table WHERE id_person = p.id_person)</pre>

こんなに サーブクイーリーを 使えば 求める 数 ある. ところが リストが 多くなれば 深刻な 性能 低下 現象が 起る ことだ.

## 質問 &#8211; サーブクイーリーを 使うの なくて 求める 数 ある 方法は?

サーブクイーリーを 使うの なくて 求める 数 ある 方法は 何が あるか?

私が 試みた 方法は 下の クイーリーだ.

<pre class="brush: sql; gutter: true; first-line: 1">SELECT *, MAX(date_written)
FROM person_class_relation_table
GROUP BY id_person</pre>

こんなに するから 親切に id\_personで グループが 建てられて 出たし, date\_written 項目は 違う データたちと 何らの 構わずに そのまま 最高値だけ 出た. すなわち, id\_person 1番(回)は 1半分だと するのに 2半分だと 出た. ところが date\_written銀 最新値. OTL;; やっぱりGROUP BY増えた id_personを 基準で グループだけ 作って 与える やつだった のだ…

次では こんなに 日 見たが 作動するの なかった.

<pre class="brush: sql; gutter: true; first-line: 1; highlight: [4]">SELECT *
FROM person_class_relation_table
GROUP BY id_person
WHERE date_written = MAX(date_written)</pre>

4番(回) 竝びが 間違い 表示された. あのように くぎ 使うという エラーが 出た ことだ そのまま.

ヨトンガンに, そのため 故水気たち頃 質問させていただく. 私が MySQLに 本当 脆弱だという のを 今更 感じながら 質問する.

**これ 場合 代替 どうに すると しようか?! **(<a target="_top" href="http://phpschool.com/link/qna_db/186559">ような 内容を PHP Schoolに 質問した.</a>)

## PHPSchoolで 草の葉っぱ 様が 日 準 <a target="_top" href="http://www.phpschool.com/gnuboard4/bbs/board.php?bo_table=qna_db&wr_id=186559#c_186560">返事</a>

> サーブクイーリー なく 求める 方法は ない の ようです.  
> いっそ 状態フィールドを 一つ もっと 入力して  
> insert時 新しい データは 状態 フィールド = 1 路 入力して,  
> 同一 id_personこれ 存在すれば 過去 データの 状態フィールド = 0で update させる のが 望ましくて 見えます.  
> それでは 敢えて group byを 夏至 ないとしても where 状態フィールド = 1 だけでも 願う 效果を 得る 数 あろう 見ます.
> 
> 勿論 select街 もっと 頻繁に 起きて update?増えた 自主 起きるの ないという 条件の下で 話です.

こんなに する 蟹 ましな の ようだ.

下は table 生成 クイーリーだ. 参考すれば なる.

<pre class="brush: sql; gutter: true; first-line: 1">--
-- テーブル 構造 `person_class_relation_table`
--

CREATE TABLE IF NOT EXISTS `person_class_relation_table` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#039;id&#039;,
  `id_person` int(11) NOT NULL COMMENT &#039;id_person&#039;,
  `id_class` int(11) NOT NULL COMMENT &#039;id_class&#039;,
  `date_written` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#039;入力日時&#039;,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=54 ;

--
-- テーブルの ダンプ データ `person_class_relation_table`
--

INSERT INTO `person_class_relation_table` (`id`, `id_person`, `id_class`, `date_written`) VALUES
(1, 1, 2, &#039;2012-03-30 17:56:58&#039;),
(2, 2, 3, &#039;2012-03-30 17:56:58&#039;),
(3, 3, 4, &#039;2012-03-30 17:56:58&#039;),
(4, 4, 5, &#039;2012-03-30 17:56:58&#039;),
(5, 5, 6, &#039;2012-03-30 17:56:58&#039;),
(6, 6, 7, &#039;2012-03-30 17:56:58&#039;),
(7, 7, 1, &#039;2012-03-30 17:56:58&#039;),
(8, 8, 2, &#039;2012-03-30 17:56:58&#039;),
(9, 9, 3, &#039;2012-03-30 17:56:58&#039;),
(10, 10, 4, &#039;2012-03-30 17:56:58&#039;),
(11, 11, 5, &#039;2012-03-30 17:56:58&#039;),
(12, 12, 6, &#039;2012-03-30 17:56:58&#039;),
(13, 13, 7, &#039;2012-03-30 17:56:58&#039;),
(14, 14, 1, &#039;2012-03-30 17:56:58&#039;),
(15, 15, 2, &#039;2012-03-30 17:56:58&#039;),
(16, 16, 3, &#039;2012-03-30 17:56:58&#039;),
(17, 17, 4, &#039;2012-03-30 17:56:58&#039;),
(18, 18, 5, &#039;2012-03-30 17:56:58&#039;),
(19, 19, 6, &#039;2012-03-30 17:56:58&#039;),
(20, 20, 7, &#039;2012-03-30 17:56:58&#039;),
(21, 21, 1, &#039;2012-03-30 17:56:58&#039;),
(22, 22, 2, &#039;2012-03-30 17:56:58&#039;),
(23, 23, 3, &#039;2012-03-30 17:56:58&#039;),
(24, 24, 4, &#039;2012-03-30 17:56:58&#039;),
(25, 25, 5, &#039;2012-03-30 17:56:58&#039;),
(26, 26, 6, &#039;2012-03-30 17:56:58&#039;),
(27, 27, 7, &#039;2012-03-30 17:56:58&#039;),
(28, 28, 1, &#039;2012-03-30 17:56:58&#039;),
(29, 29, 2, &#039;2012-03-30 17:56:58&#039;),
(30, 30, 3, &#039;2012-03-30 17:56:58&#039;),
(31, 31, 4, &#039;2012-03-30 17:56:58&#039;),
(32, 32, 5, &#039;2012-03-30 17:56:58&#039;),
(33, 33, 6, &#039;2012-03-30 17:56:58&#039;),
(34, 34, 7, &#039;2012-03-30 17:56:58&#039;),
(35, 35, 1, &#039;2012-03-30 17:56:58&#039;),
(36, 36, 2, &#039;2012-03-30 17:56:58&#039;),
(37, 37, 3, &#039;2012-03-30 17:56:58&#039;),
(38, 38, 4, &#039;2012-03-30 17:56:58&#039;),
(39, 39, 5, &#039;2012-03-30 17:56:58&#039;),
(40, 40, 6, &#039;2012-03-30 17:56:58&#039;),
(41, 41, 7, &#039;2012-03-30 17:56:58&#039;),
(42, 42, 1, &#039;2012-03-30 17:56:58&#039;),
(43, 43, 2, &#039;2012-03-30 17:56:58&#039;),
(44, 44, 3, &#039;2012-03-30 17:56:58&#039;),
(45, 45, 4, &#039;2012-03-30 17:56:58&#039;),
(46, 46, 5, &#039;2012-03-30 17:56:58&#039;),
(47, 47, 6, &#039;2012-03-30 17:56:58&#039;),
(48, 48, 7, &#039;2012-03-30 17:56:58&#039;),
(49, 49, 1, &#039;2012-03-30 17:56:58&#039;),
(50, 1, 4, &#039;2012-04-05 16:02:07&#039;),
(51, 2, 1, &#039;2012-04-05 16:36:49&#039;),
(52, 3, 1, &#039;2012-04-04 16:37:09&#039;),
(53, 1, 1, &#039;2012-04-05 16:40:25&#039;);</pre>

&nbsp;